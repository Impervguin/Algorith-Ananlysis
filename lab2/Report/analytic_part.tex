\chapter{Аналитическая часть}
\section{Теоретические сведения по матрицам}

Матрицей \cite[390 с.]{math} размера m на n называется таблица некоторых элементов $a_{jk}$, которая задаётся в виде:

\begin{equation}
	\label{eq:matrix}
	A = \begin{pmatrix}
		a_{11} & a_{12} & \dots & a_{1n} \\
		a_{21} & a_{22} & \dots & a_{2n} \\
		\dots & \dots & \dots & \dots \\
		a_{m1} & a_{m2} & \dots & a_{mn} \\
	\end{pmatrix}
\end{equation}
При этом такую матрицу можно сокращённо записать:
\begin{equation}
	\label{eq:mat-form}
	\begin{matrix}
		A = [a_{jk}], &0 \leq j \leq m, 0 \leq k \leq n.
	\end{matrix}
\end{equation}

Элементы $a_{jk}$ называют элементами матрицы.

Если для элементов матрицы определена операция умножения, то можно ввести умножение матриц \cite[392 c.]{math} следующим образом: Произведение матрицы $A = [a_{ik}]$ размера m на n на матрицу $B = [b_{kj}]$ размера n на r есть матрица $C = [C_{ij}]$ размера m на r, при этом элементы этой матрицы определяются по формуле \ref{eq:mat-mult}:

\begin{equation}
	\label{eq:mat-mult}
	\begin{matrix}
		c_{ij} = \sum_{k=1}^{n}a_{ik}*b_{kj}, &0 \leq i \leq m, 0 \leq j \leq r.
	\end{matrix}
\end{equation} 


\section{Стандартный метод умножения матриц}

Стандартный алгоритм построен на определении матричного умножения, без каких-либо усложнений или ухищрений. В данном методе результирующая матрица рассчитывается поэлементно по формуле \ref{eq:mat-mult}.

\section{Алгоритм Винограда}

Можно заметить, что в формуле \ref{eq:mat-mult} элемент матрицы рассчитывается как скалярное произведение соответствующих строки на столбец исходных матриц. Скалярное произведение определяется как:

\begin{equation}
	\label{eq:scalar-mult}
		\vec{V}\vec{W} = V_1W_1 + V_2W_2 + \dots + V_nW_n,
\end{equation}
где n – размер векторов.

Скалярное произведение \ref{eq:scalar-mult} можно записать в виде \ref{eq:scalar-even} для чётных n и \ref{eq:scalar-odd} – для нечётных n

\begin{equation}
	\label{eq:scalar-even}
	\begin{matrix}
		\vec{V}\vec{W} = (V_1 + W_2)(V_2 + W_1) + \dots + (V_{n-1} + W_n)(V_n + W_{n-1}) - \\ - V_1V_2 - W_1W_2 - \dots - V_{n-1}V_n - W_{n-1}W_n
	\end{matrix}
\end{equation}


\begin{equation}
	\label{eq:scalar-odd}
	\begin{matrix}
		\vec{V}\vec{W} = (V_1 + W_2)(V_2 + W_1) + \dots + (V_{n-2} + W_{n-1})(V_{n-1} + W_{n-2}) - \\ - V_1V_2 - W_1W_2 - \dots - V_{n-2}V_{n-1} - W_{n-2}W_{n-1} + V_nW_n
	\end{matrix}
\end{equation}

В этих формулах  интересно то, что их части можно посчитать заранее для каждой из матриц, и для первой хранить значения для каждой строки, а для второй – для каждого столбца. За счёт этого алгоритм может получится эффективнее, ценой дополнительной памяти на хранение значений для матриц.

\section*{Вывод}
В результате аналитического раздела были рассмотрены математические основы стандартного алгоритма умножения матриц и алгоритма Винограда.

\clearpage
